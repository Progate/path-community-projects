## 負荷をかけてみよう

### nginxのアクセスログにレスポンスタイムを出すようにしてみよう

Nginx はアクセスログを使用してリクエストの情報を記録します。

まずは既存のアクセスログを確認してみましょう。Nginx のアクセスログは通常、`/var/log/nginx/access.log` に保存されています。以下のコマンドを使用して、アクセスログの内容を表示します。

```terminal
$ cat /var/log/nginx/access.log 
# 例
192.168.1.1 - - [31/Mar/2024:00:10:40 +0000] "GET /index.php HTTP/1.1" 200 804 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36 Edg/90.0.818.46"
```

各フィールドは次のとおりです:

- **192.168.1.1**: リクエストを行ったクライアントの IP アドレス（$remote_addr）
- **-**: RFC 1413 アイデンティティ（ここでは使用されていない）
- **-**: ユーザー名（HTTP 認証がない場合は使用されない）
- **[31/Mar/2024:00:10:40 +0000]**: リクエストが行われた日時
- **GET /index.php HTTP/1.1**: リクエストメソッド、URI、HTTP プロトコルのバージョン
- **200**: HTTP ステータスコード
- **804**: レスポンスで送信されたバイト数（ヘッダーを除く）
- **-**: リファラーURL（直接アクセスの場合は-）
- **Mozilla/5.0 ... Edg/90.0.818.46**: ユーザーエージェント文字列

デフォルトではレスポンスタイム（リクエストの処理にかかった時間）は含まれていません。レスポンスタイムをアクセスログに含めることで、リクエストの処理時間を監視し、パフォーマンスの問題を特定するのに役立ちます。

Nginx では、`$request_time` 変数を使用してレスポンスタイムをログに記録できます。この変数はリクエストの処理にかかった全時間（秒単位）を示します。

レスポンスタイムをアクセスログに含めるには、Nginx の設定ファイルでログフォーマットをカスタマイズします。これを行うには、まず `http` コンテキストまたは `server` コンテキスト内で `log_format` ディレクティブを定義し、その後、使用するアクセスログの定義にこのフォーマットを適用します。

1. カスタムログフォーマットの定義

    まず、以下のように設定することで、レスポンスタイムを含むカスタムログフォーマットを定義しましょう。今回はフォーマットに `request_time` を含め、それを `ltsv` という名前で定義しています。

    ```terminal
    $ sudo vi /etc/nginx/nginx.conf
    ```

    ```nginx
    http {
        log_format ltsv 'time:$time_iso8601\t'
                    'remote_addr:$remote_addr\t'
                    'request_method:$request_method\t'
                    'request_length:$request_length\t'
                    'request_uri:$request_uri\t'
                    'https:$https\t'
                    'uri:$uri\t'
                    'query_string:$query_string\t'
                    'status:$status\t'
                    'bytes_sent:$bytes_sent\t'
                    'body_bytes_sent:$body_bytes_sent\t'
                    'referer:$http_referer\t'
                    'useragent:$http_user_agent\t'
                    'forwardedfor:$http_x_forwarded_for\t'
                    'request_time:$request_time\t'
                    'upstream_response_time:$upstream_response_time\t'
                    'host:$host';
        
        # その他の設定...
    }
    ```

2. カスタムログフォーマットの使用

    次に、定義したログフォーマットを使用するように Nginx のサーバーブロックまたはロケーションブロックを設定します。`access_log` ディレクティブを使用して、ログファイルのパスと使用するログフォーマット（この例では `ltsv`）を指定します。

    ```terminal
    $ sudo vi /etc/nginx/sites-available/php.conf
    ```

    ```nginx
    server {
        listen 80;
        server_name php.aws;

        access_log /var/log/nginx/access.log ltsv;

        # その他の設定...
    }
    ```

    この設定により、`/var/log/nginx/access.log` に出力されるログエントリには、リクエストの処理時間が秒単位で含まれるようになります。

3. 変更の適用

    設定を変更した後は、設定の構文が正しいことを確認するために `sudo nginx -t` を実行し、問題がなければ `sudo systemctl reload nginx` または `sudo nginx -s reload` で Nginx を再読み込みして設定を適用します。

    これで、Nginx のアクセスログにレスポンスタイムが含まれるようになり、パフォーマンスの監視やトラブルシューティングに役立てることができます。

```sh
time:2024-03-31T00:10:40+00:00	remote_addr:185.224.128.43	request_method:GET	request_length:425	request_uri:/	https:	uri:/index.php	query_string:-	status:200	bytes_sent:1007	body_bytes_sent:804	referer:-	useragent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36 Edg/90.0.818.46	forwardedfor:-	request_time:0.000	upstream_response_time:0.000	host:54.238.193.253

```

各フィールドは次のとおりです:

- **time**: ログが記録されたISO 8601 形式の時刻。
- **remote_addr**: クライアント（ユーザーのブラウザなど）の IP アドレス。
- **request_method**: HTTP リクエストメソッド（この場合は `GET`）。
- **request_length**: リクエストの全長（ヘッダーを含むバイト数）。
- **request_uri**: リクエストされた完全な URI（この場合はルート `/`）。
- **https**: HTTPS を使用している場合、ここに値が入る（ここでは空白、つまり HTTP リクエスト）。
- **uri**: リクエストされた URI のパス（この場合は `/index.php`）。
- **query_string**: クエリストリング（存在しない場合は `-`）。
- **status**: HTTP レスポンスのステータスコード（`200` は成功を意味する）。
- **bytes_sent**: クライアントへ送信された全バイト数（ヘッダーを含む）。
- **body_bytes_sent**: クライアントへ送信されたボディのバイト数（ヘッダーを除く）。
- **referer**: どのページからリクエストが来たかを示すリファラーURL（直接アクセスの場合は `-`）。
- **useragent**: ユーザーエージェントの文字列（クライアントのブラウザや OS に関する情報）。
- **forwardedfor**: X-Forwarded-For ヘッダーの内容（プロキシ経由のリクエストの元の IP アドレス）。この場合は `-`。
- **request_time**: リクエストの処理にかかった時間（秒単位）。この場合は `0.000` 秒。
- **upstream_response_time**: アップストリームサーバー（例えば PHP-FPM やバックエンドアプリケーションサーバー）からのレスポンスにかかった時間。この場合は `0.000` 秒。
- **host**: リクエストが送信されたホスト名または IP アドレス。

このログフォーマットは、Web サーバーのパフォーマンスモニタリングやトラブルシューティングに役立つ詳細な情報を提供します。リクエストの処理時間、バイト数、使用されたメソッド、ステータスコードなどから、サーバーの状態や特定のリクエストの問題を把握できます。

### htopコマンドを使ってみよう

`htop` コマンドは、Linux システムでプロセスをリアルタイムで監視するためのインタラクティブなプロセスビューアです。Linux システムでプロセスをモニタリングするためによく使われます。`htop` を使用すると、システムのリソース使用状況を視覚的に確認できます。

```terminal
$ htop
```

<img width="737" alt="image" src="https://github.com/Progate/path-community-projects/assets/26600620/7f1973bf-04d0-44bc-812c-1c402f1ac673">

### htopでメモリ順に並べてみよう

システムのプロセスをメモリ使用量や CPU 使用率に基づいて並べ替えることができます。

1. `htop` を起動します。
2. `F6` キーを押してソート条件の選択メニューを開きます。
3. `PERCENT_MEM`（メモリ使用率）を選択して、Enter キーを押します。

これにより、プロセスがメモリ使用率の高い順に並べ替えられます。

### htopでCPU順に並べてみよう

1. `htop` を起動します。
2. `F6` キーを押してソート条件の選択メニューを開きます。
3. `CPU%`（CPU 使用率）を選択して、Enter キーを押します。

これにより、プロセスが CPU 使用率の高い順に並べ替えられます。

### ブラウザで負荷をかけてみよう

ブラウザを開いて負荷を掛けてみましょう。`htop` を開いてシステムのリソース使用状況を監視しながら、ブラウザでウェブサイトにアクセスしてみます。

ツールなどを使って負荷を掛ける方法もありますが、今回はブラウザでタブを開いて `F5` キー、もしくは `Ctrl + r` か `⌘ + r` を連打することで、数値の動きやログを見てみましょう。

CPU 順に並び替えて沢山リロードを行うと、Nginx や PHP-FPM などのプロセスが上位に出てくる瞬間を確認できるでしょう。

これらの操作を通じて、システムのパフォーマンスをモニタリングし、どのプロセスが最もリソースを消費しているかを視覚的に確認できることを体験しました。`htop` はリアルタイムで情報を更新するため、負荷テストの影響を即座に見ることが可能です。

### dstatコマンドを使ってみよう

`dstat` コマンドは、システムのリソース使用状況をリアルタイムで監視するためのツールです。`dstat` を使用すると、CPU 使用率、メモリ使用量、ディスク I/O、ネットワークトラフィックなどの情報を表示できます。

### dstatをインストールしてみよう

`dstat` をインストールするには、以下のコマンドを実行します。

```terminal
$ sudo apt install dstat
```

### dstat -tlamp --top-cpu-adv --top-io-adv と打ってみよう

```terminal
$ dstat -tlamp --top-cpu-adv --top-io-adv
/usr/bin/dstat:2619: DeprecationWarning: the imp module is deprecated in favour of importlib and slated for removal in Python 3.12; see the module's documentation for alternative uses
  import imp
Terminal width too small, trimming output.
----system---- ---load-avg--- --total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system-->
     time     | 1m   5m  15m |usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw >
30-03 12:33:25|0.07 0.03    0|  0   0 100   0   0|  89k   45k|   0     0 |   0     0 |  27    25 >
30-03 12:33:26|0.07 0.03    0|  1   0  99   0   0|   0     0 | 156B 1412B|   0     0 |  48    42 >
30-03 12:33:27|0.06 0.03    0|  1   0  99   0   0|   0     0 |  52B  516B|   0     0 |  46    39 >
30-03 12:33:28|0.06 0.03    0|  1   0  99   0   0|   0     0 | 128B  606B|   0     0 |  58    45 >
30-03 12:33:29|0.06 0.03    0|  1   0  99   0   0|   0     0 | 116B  930B|   0     0 |  52    33 >
30-03 12:33:30|0.06 0.03    0|  1   1  98   0   0|   0     0 | 116B  930B|   0     0 |  48    34 >
30-03 12:33:31|0.06 0.03    0|  1   0  99   0   0|   0    80k|  52B  516B|   0     0 |  64    51 >
30-03 12:33:32|0.06 0.03    0|  1   0  99   0   0|   0     0 |  52B  524B|   0     0 |  46    35 >
30-03 12:33:33|0.06 0.03    0|  1   0  99   0   0|   0     0 | 140B  570B|   0     0 |  42    30 >
30-03 12:33:34|0.06 0.03    0|  1   0  99   0   0|   0     0 |  52B  516B|   0     0 |  48    43 >
30-03 12:33:35|0.06 0.03    0|  1   0  99   0   0|   0     0 |  52B  516B|   0     0 |  40    34 >
30-03 12:33:36|0.06 0.03    0|  2   0  98   0   0|   0     0 |  52B  516B|   0     0 |  42    36 >
30-03 12:33:37|0.05 0.02    0|  0   1  99   0   0|   0     0 |  52B  516B|   0     0 |  46    38 >
30-03 12:33:38|0.05 0.02    0|  1   1  98   0   0|   0     0 | 232B 1074B|   0     0 |  64    41 >
30-03 12:33:39|0.05 0.02    0|  1   0  99   0   0|   0     0 |  52B  516B|   0     0 |  40    33 >
```

`dstat` コマンドを実行すると、システムのリソース使用状況がリアルタイムで表示されます。`-tlamp` オプションは一文字のオプションの連なりで、CPU 使用率(a)、ディスク I/O(a)、ネットワークトラフィック(a)、時間(t)、ロードアベレージ(l)、メモリ使用量(m)、プロセス情報(p) などの情報を表示するためのオプションです。`--top-cpu-adv` オプションは、CPU 使用率の高いプロセスを表示するためのオプションです。`--top-io-adv` オプションは、ディスク I/O の高いプロセスを表示するためのオプションです。詳細は `man dstat` コマンドなどで確認しましょう。

`dstat` の出力は多岐にわたる情報を含んでいます。ウェブブラウザで負荷をかけながら監視する際に特に注目すべきカラムについて説明します。

- システム全般
  - **`time`**: 現在の時刻。監視している期間を把握するのに役立ちます。
- 負荷平均
  - **`1m 5m 15m`**: それぞれ過去 1 分間、5 分間、15 分間の平均負荷。システムの負荷がどのように変化しているかの傾向を把握できます。CPU のコア数を超える値が続く場合は、高負荷の状態です。
- CPU 使用率
  - **`usr`**: ユーザーレベルでの CPU 使用率。アプリケーションの処理に使われています。
  - **`sys`**: システムレベルでの CPU 使用率。カーネルレベルの操作に使われています。
  - **`idl`**: アイドル状態の CPU の割合。この値が低いと、CPU が活発に使用されていることを意味します。
  - **`wai`**: I/O 待ちの割合。この値が高いと、ディスク I/O などがボトルネックになっている可能性があります。
- ディスク I/O
  - **`read writ`**: ディスクからの読み込みと書き込みの速度。サーバーがデータをどれだけ読み書きしているかの指標です。
- ネットワークトラフィック
  - **`recv send`**: ネットワーク経由での受信と送信データ量。ウェブアプリケーションでは、この値が増加するのは一般的ですが、異常な増加は注意が必要です。
- ページング
  - **`in out`**: スワップイン（ディスクから RAM への読み込み）とスワップアウト（RAM からディスクへの書き込み）の量。スワップの使用が多い場合は、物理メモリが不足している可能性があります。
- システム
  - **`int csw`**: 割り込み回数とコンテキストスイッチの回数。これらの値が高いと、システムが多くのタスクを同時に処理していることを意味します。
- メモリ使用状況
  - **`used free buff cach`**: 使用中のメモリ、空きメモリ、バッファ、キャッシュに使われているメモリ量。メモリの使用状況とシステムのキャッシング効率を示します。
- プロセス
  - **`run blk new`**: 実行中、ブロックされている、新しく生成されたプロセスの数。システムがどれだけ忙しいかを示す指標です。

これらのカラムから、システムの現在の状態と、負荷テストがシステムにどのような影響を与えているかを理解できます。特に CPU の使用率、メモリの使用状況、ディスク I/O、ネットワークトラフィックは、サーバーのパフォーマンスに直接影響を及ぼす重要な指標です。

### ウェブブラウザで負荷をかけながらdstatを見てみよう

ブラウザで負荷をかけながら `dstat` コマンドの出力を確認してみましょう。

下記のような変化が見られるかもしれません。

- recv や send の急激な増加
- int や csw の急激な増加
- most-expensive-cpu-process の変化

### 判定のためにサーバー情報を.envファイルに記載しよう

最後に、現時点の数値で `.env` ファイルを更新してください。変化はありましたか？

```.env
# プロセスは何個ぐらい起動してる？
ANSWER_CHECK_SERVER_STATUS_PS_COUNT=00

# このサーバーのメモリはどのぐらい？そのうちどのぐらい使われてる？
ANSWER_CHECK_SERVER_STATUS_MEM_TOTAL_MIB=000.0
ANSWER_CHECK_SERVER_STATUS_MEM_USED_MIB=000.0

# このサーバーのディスク容量はどのぐらい？そのうちどのぐらい使われてる？
ANSWER_CHECK_SERVER_STATUS_DISK_TOTAL_GB="0.0G"
ANSWER_CHECK_SERVER_STATUS_DISK_USED_GB="0.0G"
```

---

更新できたら `progate submit` を実行して判定してみましょう！
