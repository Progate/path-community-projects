## 負荷をかけてみよう

### nginxのアクセスログにレスポンスタイムを出すようにしてみよう

Nginx はアクセスログを使用してリクエストの情報を記録します。

まずは既存のアクセスログを確認してみましょう。Nginx のアクセスログは通常、`/var/log/nginx/access.log` に保存されています。`tail` コマンドを使用して、アクセスログの内容を表示します。

```terminal
$ tail /var/log/nginx/access.log 
# 例
192.168.1.1 - - [31/Mar/2024:00:10:40 +0000] "GET /test.php HTTP/1.1" 200 804 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36 Edg/90.0.818.46"
```

各フィールドは次のとおりです:

- **192.168.1.1**: リクエストを行ったクライアントの IP アドレス（$remote_addr）
- **-**: RFC 1413 アイデンティティ（ここでは使用されていない）
- **-**: ユーザー名（HTTP 認証がない場合は使用されない）
- **[31/Mar/2024:00:10:40 +0000]**: リクエストが行われた日時
- **GET /test.php HTTP/1.1**: リクエストメソッド、URI、HTTP プロトコルのバージョン
- **200**: HTTP ステータスコード
- **804**: レスポンスで送信されたバイト数（ヘッダーを除く）
- **-**: リファラーURL（直接アクセスの場合は-）
- **Mozilla/5.0 ... Edg/90.0.818.46**: ユーザーエージェント文字列

<details>
  <summary>なぜ cat ではなく tail を使うべきなのか</summary>

`tail` コマンドは、ファイルの末尾部分だけを表示します。デフォルトでは、最後の 10 行を表示しますが、オプションを使うことで表示する行数を指定できます。

`tail` を使うべき理由は次のとおりです:

1. **ログファイルのサイズが大きい場合のパフォーマンス**:
   - ログファイルは非常に大きくなることが多く、`cat` コマンドを使うとすべての行が表示されてしまい、処理が遅くなることがあります。
   - `tail` コマンドを使うことで、必要な末尾の数行だけを表示するため、パフォーマンスが向上します。
2. **最新のログエントリの確認**:
   - 一般的に、ログファイルの確認は最新のエントリを見るために行います。`tail` コマンドはファイルの末尾を表示するため、最新のログエントリをすぐに確認できます。
3. **継続的なモニタリング**:
   - `tail` には `-f` オプションがあり、これを使うと新しいログエントリが追加されるたびにリアルタイムで表示されます。これは継続的なログの監視に非常に便利です。

   ```terminal
   $ tail -f /var/log/nginx/access.log
   ```

このように、`cat` よりも `tail` を使うほうが、特に大きなログファイルを扱う場合や最新のログエントリを確認する場合に適しています。

</details>

デフォルトではレスポンスタイム（リクエストの処理にかかった時間）は含まれていません。レスポンスタイムをアクセスログに含めることで、リクエストの処理時間を監視し、パフォーマンスの問題を特定するのに役立ちます。

Nginx では、`$request_time` 変数を使用してレスポンスタイムをログに記録できます。この変数はリクエストの処理にかかった全時間（秒単位）を示します。

レスポンスタイムをアクセスログに含めるには、Nginx の設定ファイルでログフォーマットをカスタマイズします。これを行うには、まず `http` コンテキストまたは `server` コンテキスト内で `log_format` ディレクティブを定義し、その後、使用するアクセスログの定義にこのフォーマットを適用します。

1. Nginx の設定ファイルを開く

    ```terminal
    $ sudo vi /etc/nginx/nginx.conf
    ```

2. カスタムログフォーマットの定義

    まず、以下のように設定することで、レスポンスタイムを含むカスタムログフォーマットを定義しましょう。今回はフォーマットに `request_time` を含め、それを `ltsv` という名前で定義しています。

    ```nginx
    http {
        
        # その他の設定...

        ##
        # Logging Settings
        ##
        log_format ltsv 'time:$time_iso8601\t'
                    'remote_addr:$remote_addr\t'
                    'request_method:$request_method\t'
                    'request_length:$request_length\t'
                    'request_uri:$request_uri\t'
                    'https:$https\t'
                    'uri:$uri\t'
                    'query_string:$query_string\t'
                    'status:$status\t'
                    'bytes_sent:$bytes_sent\t'
                    'body_bytes_sent:$body_bytes_sent\t'
                    'referer:$http_referer\t'
                    'useragent:$http_user_agent\t'
                    'forwardedfor:$http_x_forwarded_for\t'
                    'request_time:$request_time\t'
                    'upstream_response_time:$upstream_response_time\t'
                    'host:$host';
        
        # その他の設定...
    }
    ```

3. カスタムログフォーマットの使用

    次に、定義したログフォーマットを使用するように Nginx のサーバーブロックまたはロケーションブロックを設定します。`access_log` ディレクティブを使用して、ログファイルのパスと使用するログフォーマット（この例では `ltsv`）を指定します。

    ```nginx
    http {

        # その他の設定...
        
        ##
        # Logging Settings
        ##

        access_log /var/log/nginx/access.log ltsv;

        # その他の設定...
    }
    ```

    この設定により、`/var/log/nginx/access.log` に出力されるログエントリには、リクエストの処理時間が秒単位で含まれるようになります。

4. 変更の適用

    設定を変更した後は、設定の構文が正しいことを確認するために `sudo nginx -t` を実行し、問題がなければ `sudo systemctl reload nginx` または `sudo nginx -s reload` で Nginx を再読み込みして設定を適用します。

    これで、Nginx のアクセスログにレスポンスタイムが含まれるようになり、パフォーマンスの監視やトラブルシューティングに役立てることができます。

    ```sh
    time:2024-03-31T00:10:40+00:00	remote_addr:185.224.128.43	request_method:GET	request_length:425	request_uri:/	https:	uri:/test.php	query_string:-	status:200	bytes_sent:1007	body_bytes_sent:804	referer:-	useragent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36 Edg/90.0.818.46	forwardedfor:-	request_time:0.000	upstream_response_time:0.000	host:54.238.193.253

    ```

    各フィールドは次のとおりです:

    - **time**: ログが記録された ISO 8601 形式の時刻。
    - **remote_addr**: クライアント（ユーザーのブラウザなど）の IP アドレス。
    - **request_method**: HTTP リクエストメソッド（この場合は `GET`）。
    - **request_length**: リクエストの全長（ヘッダーを含むバイト数）。
    - **request_uri**: リクエストされた完全な URI（この場合はルート `/`）。
    - **https**: HTTPS を使用している場合、ここに値が入る（ここでは空白、つまり HTTP リクエスト）。
    - **uri**: リクエストされた URI のパス（この場合は `/test.php`）。
    - **query_string**: クエリストリング（存在しない場合は `-`）。
    - **status**: HTTP レスポンスのステータスコード（`200` は成功を意味する）。
    - **bytes_sent**: クライアントへ送信された全バイト数（ヘッダーを含む）。
    - **body_bytes_sent**: クライアントへ送信されたボディのバイト数（ヘッダーを除く）。
    - **referer**: どのページからリクエストが来たかを示すリファラーURL（直接アクセスの場合は `-`）。
    - **useragent**: ユーザーエージェントの文字列（クライアントのブラウザや OS に関する情報）。
    - **forwardedfor**: X-Forwarded-For ヘッダーの内容（プロキシ経由のリクエストの元の IP アドレス）。この場合は `-`。
    - **request_time**: リクエストの処理にかかった時間（秒単位）。この場合は `0.000` 秒。
    - **upstream_response_time**: アップストリームサーバー（例えば PHP-FPM やバックエンドアプリケーションサーバー）からのレスポンスにかかった時間。この場合は `0.000` 秒。
    - **host**: リクエストが送信されたホスト名または IP アドレス。

    このログフォーマットは、Web サーバーのパフォーマンスモニタリングやトラブルシューティングに役立つ詳細な情報を提供します。リクエストの処理時間、バイト数、使用されたメソッド、ステータスコードなどから、サーバーの状態や特定のリクエストの問題を把握できます。

5. 設定が正しいことを確認するために、`sudo nginx -t` コマンドを実行します。

    ```terminal
    $ sudo nginx -t
    nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
    nginx: configuration file /etc/nginx/nginx.conf test is successful
    ```

6. 設定に問題がなければ、`sudo systemctl reload nginx` コマンドで Nginx を再読み込みします。

    ```terminal
    $ sudo systemctl reload nginx
    ```

### htopコマンドを使ってみよう

`htop` コマンドは、Linux システムでプロセスをリアルタイムで監視するためのインタラクティブなプロセスビューアです。Linux システムでプロセスをモニタリングするためによく使われます。`htop` を使用すると、システムのリソース使用状況を視覚的に確認できます。

```terminal
$ htop
```

<img width="737" alt="image" src="https://github.com/Progate/path-community-projects/assets/26600620/7f1973bf-04d0-44bc-812c-1c402f1ac673">

### htopでメモリ順に並べてみよう

システムのプロセスをメモリ使用量や CPU 使用率に基づいて並べ替えることができます。

1. `htop` を起動します。
2. `F6` キーを押してソート条件の選択メニューを開きます。
3. `PERCENT_MEM`（メモリ使用率）を選択して、Enter キーを押します。

これにより、プロセスがメモリ使用率の高い順に並べ替えられます。

### htopでCPU順に並べてみよう

1. `htop` を起動します。
2. `F6` キーを押してソート条件の選択メニューを開きます。
3. `CPU%`（CPU 使用率）を選択して、Enter キーを押します。

これにより、プロセスが CPU 使用率の高い順に並べ替えられます。

### ブラウザで負荷をかけてみよう

ブラウザを開いて負荷を掛けてみましょう。`htop` を開いてシステムのリソース使用状況を監視しながら、ブラウザでウェブサイトにアクセスしてみます。

ツールなどを使って負荷を掛ける方法もありますが、今回はブラウザでタブを開いて `F5` キー、もしくは `Ctrl + r` か `⌘ + r` を連打することで、数値の動きやログを見てみましょう。

CPU 順に並び替えて沢山リロードを行うと、Nginx や PHP-FPM などのプロセスが上位に出てくる瞬間を確認できるでしょう。

これらの操作を通じて、システムのパフォーマンスをモニタリングし、どのプロセスが最もリソースを消費しているかを視覚的に確認できることを体験しました。`htop` はリアルタイムで情報を更新するため、負荷テストの影響を即座に見ることが可能です。

### dstatコマンドを使ってみよう

`dstat` コマンドは、システムのリソース使用状況をリアルタイムで監視するためのツールです。`dstat` を使用すると、CPU 使用率、メモリ使用量、ディスク I/O、ネットワークトラフィックなどの情報を表示できます。

### dstatをインストールしてみよう

`dstat` をインストールするには、以下のコマンドを実行します。

```terminal
$ sudo apt install dstat
```

### dstat -tlamp --top-cpu-adv --top-io-adv と打ってみよう

```terminal
$ dstat -tlamp --top-cpu-adv --top-io-adv
/usr/bin/dstat:2619: DeprecationWarning: the imp module is deprecated in favour of importlib and slated for removal in Python 3.12; see the module's documentation for alternative uses
  import imp
Terminal width too small, trimming output.
----system---- ---load-avg--- --total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system-->
     time     | 1m   5m  15m |usr sys idl wai stl| read  writ| recv  send|  in   out | int   csw >
30-03 12:33:25|0.07 0.03    0|  0   0 100   0   0|  89k   45k|   0     0 |   0     0 |  27    25 >
30-03 12:33:26|0.07 0.03    0|  1   0  99   0   0|   0     0 | 156B 1412B|   0     0 |  48    42 >
30-03 12:33:27|0.06 0.03    0|  1   0  99   0   0|   0     0 |  52B  516B|   0     0 |  46    39 >
30-03 12:33:28|0.06 0.03    0|  1   0  99   0   0|   0     0 | 128B  606B|   0     0 |  58    45 >
30-03 12:33:29|0.06 0.03    0|  1   0  99   0   0|   0     0 | 116B  930B|   0     0 |  52    33 >
30-03 12:33:30|0.06 0.03    0|  1   1  98   0   0|   0     0 | 116B  930B|   0     0 |  48    34 >
30-03 12:33:31|0.06 0.03    0|  1   0  99   0   0|   0    80k|  52B  516B|   0     0 |  64    51 >
30-03 12:33:32|0.06 0.03    0|  1   0  99   0   0|   0     0 |  52B  524B|   0     0 |  46    35 >
30-03 12:33:33|0.06 0.03    0|  1   0  99   0   0|   0     0 | 140B  570B|   0     0 |  42    30 >
30-03 12:33:34|0.06 0.03    0|  1   0  99   0   0|   0     0 |  52B  516B|   0     0 |  48    43 >
30-03 12:33:35|0.06 0.03    0|  1   0  99   0   0|   0     0 |  52B  516B|   0     0 |  40    34 >
30-03 12:33:36|0.06 0.03    0|  2   0  98   0   0|   0     0 |  52B  516B|   0     0 |  42    36 >
30-03 12:33:37|0.05 0.02    0|  0   1  99   0   0|   0     0 |  52B  516B|   0     0 |  46    38 >
30-03 12:33:38|0.05 0.02    0|  1   1  98   0   0|   0     0 | 232B 1074B|   0     0 |  64    41 >
30-03 12:33:39|0.05 0.02    0|  1   0  99   0   0|   0     0 |  52B  516B|   0     0 |  40    33 >
```

`dstat` コマンドを実行すると、システムのリソース使用状況がリアルタイムで表示されます。`-tlamp` オプションは一文字のオプションの連なりで、CPU 使用率(a)、ディスク I/O(a)、ネットワークトラフィック(a)、時間(t)、ロードアベレージ(l)、メモリ使用量(m)、プロセス情報(p) などの情報を表示するためのオプションです。`--top-cpu-adv` オプションは、CPU 使用率の高いプロセスを表示するためのオプションです。`--top-io-adv` オプションは、ディスク I/O の高いプロセスを表示するためのオプションです。詳細は `man dstat` コマンドなどで確認しましょう。

`dstat` の出力は多岐にわたる情報を含んでいます。ウェブブラウザで負荷をかけながら監視する際に特に注目すべきカラムについて説明します。

- システム全般
  - **`time`**: 現在の時刻。監視している期間を把握するのに役立ちます。
- 負荷平均
  - **`1m 5m 15m`**: それぞれ過去 1 分間、5 分間、15 分間の平均負荷。システムの負荷がどのように変化しているかの傾向を把握できます。CPU のコア数を超える値が続く場合は、高負荷の状態です。
- CPU 使用率
  - **`usr`**: ユーザーレベルでの CPU 使用率。アプリケーションの処理に使われています。
  - **`sys`**: システムレベルでの CPU 使用率。カーネルレベルの操作に使われています。
  - **`idl`**: アイドル状態の CPU の割合。この値が低いと、CPU が活発に使用されていることを意味します。
  - **`wai`**: I/O 待ちの割合。この値が高いと、ディスク I/O などがボトルネックになっている可能性があります。
- ディスク I/O
  - **`read writ`**: ディスクからの読み込みと書き込みの速度。サーバーがデータをどれだけ読み書きしているかの指標です。
- ネットワークトラフィック
  - **`recv send`**: ネットワーク経由での受信と送信データ量。ウェブアプリケーションでは、この値が増加するのは一般的ですが、異常な増加は注意が必要です。
- ページング
  - **`in out`**: スワップイン（ディスクから RAM への読み込み）とスワップアウト（RAM からディスクへの書き込み）の量。スワップの使用が多い場合は、物理メモリが不足している可能性があります。
- システム
  - **`int csw`**: 割り込み回数とコンテキストスイッチの回数。これらの値が高いと、システムが多くのタスクを同時に処理していることを意味します。
- メモリ使用状況
  - **`used free buff cach`**: 使用中のメモリ、空きメモリ、バッファ、キャッシュに使われているメモリ量。メモリの使用状況とシステムのキャッシング効率を示します。
- プロセス
  - **`run blk new`**: 実行中、ブロックされている、新しく生成されたプロセスの数。システムがどれだけ忙しいかを示す指標です。

これらのカラムから、システムの現在の状態と、負荷テストがシステムにどのような影響を与えているかを理解できます。特に CPU の使用率、メモリの使用状況、ディスク I/O、ネットワークトラフィックは、サーバーのパフォーマンスに直接影響を及ぼす重要な指標です。

### ウェブブラウザで負荷をかけながらdstatを見てみよう

ブラウザで負荷をかけながら `dstat` コマンドの出力を確認してみましょう。

下記のような変化が見られるかもしれません。

- recv や send の急激な増加
- int や csw の急激な増加
- most-expensive-cpu-process の変化

### 判定のためにサーバー情報を.envファイルに記載しよう

最後に、現時点の数値で `questions.sh` ファイルを更新してください。変化はありましたか？

```sh
# プロセスは何個ぐらい起動してる？
ANSWER_CHECK_SERVER_STATUS_PS_COUNT=00

# このサーバーのメモリはどのぐらい？そのうちどのぐらい使われてる？
ANSWER_CHECK_SERVER_STATUS_MEM_TOTAL_MIB=000.0
ANSWER_CHECK_SERVER_STATUS_MEM_USED_MIB=000.0

# このサーバーのディスク容量はどのぐらい？そのうちどのぐらい使われてる？
ANSWER_CHECK_SERVER_STATUS_DISK_TOTAL_GB="0.0G"
ANSWER_CHECK_SERVER_STATUS_DISK_USED_GB="0.0G"
```

---

更新できたら `progate submit` を実行して判定してみましょう！

## EC2インスタンスの掃除

このタスクで作成した EC2 インスタンスは、AWS マネジメントコンソールから削除できます。インスタンスを削除することで、課金を回避できます。忘れずに停止したり削除したりしましょう。

手順は以下の通りです。

1. AWS マネジメントコンソールにログインします。
2. サービスメニューから EC2 を選択します。
3. インスタンスの一覧から削除するインスタンスを選択します。
4. インスタンスを右クリックし、`インスタンスの状態` > `終了` を選択します。
5. インスタンスの終了を確認します。

## /etc/hosts の掃除

このタスクで編集した `/etc/hosts` ファイルは、不要になったら元に戻しておきましょう。

```terminal
$ sudo vi /etc/hosts
```

`/etc/hosts` ファイルを編集し、追加した行を削除します。

```text
xxx.xxx.xxx.xxx php.aws
```

この行を削除したら、ファイルを保存してエディターを閉じます。
